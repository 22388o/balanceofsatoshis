#!/usr/bin/env node
const {lstat} = require('fs');
const {mkdir} = require('fs');
const {readdir} = require('fs');
const {readFile} = require('fs');
const {rmdir} = require('fs');
const {spawn} = require('child_process');
const {statSync} = require('fs');
const {unlink} = require('fs');
const {writeFile} = require('fs');

const {deletePayments} = require('ln-service');
const fetch = require('node-fetch');
const {findKey} = require('ln-sync');
const inquirer = require('inquirer');
const prog = require('caporal');
const {rateProviders} = require('ln-accounting');
const request = require('@alexbosworth/request');

const {accountingCategories} = require('./balances');
const {adjustFees} = require('./routing');
const {adjustSavedNodes} = require('./nodes');
const {authenticatedLnd} = require('./lnd');
const {connectToTelegram} = require('./telegram');
const {encryptToNode} = require('./encryption');
const {exchanges} = require('./fiat');
const {decryptWithNode} = require('./encryption');
const {findRecord} = require('./lnd');
const {gateway} = require('./lnd');
const {getAccountingReport} = require('./balances');
const {getBalance} = require('./balances');
const {getCertValidityDays} = require('./lnd');
const {getChainFees} = require('./chain');
const {getChannelCloses} = require('./chain');
const {getPrices} = require('./fiat');
const {getCredentials} = require('./lnd');
const {getDepositAddress} = require('./chain');
const {getFeesChart} = require('./routing');
const {getFeesPaid} = require('./routing');
const {getForwards} = require('./network');
const {getLiquidity} = require('./balances');
const {getLnds} = require('./lnd');
const {getPaidService} = require('./swaps');
const {getPeers} = require('./network');
const {getPriceChart} = require('./fiat');
const {getReceivedChart} = require('./wallets');
const {getReport} = require('./wallets');
const {getSwapCost} = require('./swaps');
const {getUtxos} = require('./chain');
const {ignoreFromAvoid} = require('./routing');
const {lndCredentials} = require('./lnd');
const marketPairs = require('./fiat').pairs;
const {openChannel} = require('./network');
const {openChannels} = require('./network');
const {pay} = require('./network');
const {peerSortOptions} = require('./network');
const {priceProviders} = require('./fiat');
const {probe} = require('./network');
const {probeDestination} = require('./network');
const {rebalance} = require('./swaps');
const {reconnect} = require('./network');
const {removePeer} = require('./network');
const {returnChart} = require('./responses');
const {returnNumber} = require('./responses');
const {returnObject} = require('./responses');
const {returnOutput} = require('./responses');
const {sendGift} = require('./network');
const {setAutopilot} = require('./network');
const {splitUtxos} = require('./chain');
const {swapApiKey} = require('./swaps');
const {swapIn} = require('./swaps');
const {swapOut} = require('./swaps');
const {swapTypes} = require('./swaps');
const {unlockWallet} = require('./wallets');
const {version} = require('./package');

const {exit} = process;
const flatten = arr => [].concat(...arr);
const {FLOAT} = prog;
const hexMatch = /^[0-9a-f]+$/i;
const {INT} = prog;
const {isArray} = Array;
const {keys} = Object;
const months = [...Array(12).keys()].map(n => ++n);
const {REPEATABLE} = prog;
const yearMatch = /^\d{4}$/;

prog
  .version(version)

  // Get accounting information
  .command('accounting', 'Get an accounting rundown')
  .argument('<category>', 'Report category', keys(accountingCategories))
  .help(`Categories: ${keys(accountingCategories).join(', ')}`)
  .help(`Rate providers: ${rateProviders.join(', ')}`)
  .option('--csv', 'Output a CSV')
  .option('--month <month>', 'Show only records for specific month', months)
  .option('--node <node_name>', 'Get details from named node')
  .option('--rate-provider <rate_provider>', 'Rate provider', rateProviders)
  .option('--year <year>', 'Show only records for specified year', yearMatch)
  .action((args, options, logger) => {
    const table = !!options.csv ? null : 'rows';

    return new Promise(async (resolve, reject) => {
      try {
        return getAccountingReport({
          request,
          category: args.category,
          is_csv: !!options.csv,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          month: options.month,
          node: options.node,
          rate_provider: options.rateProvider,
          year: options.year,
        },
        returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Direct autopilot to mirror one or more nodes on the network
  .command('autopilot', 'Enable autopilot')
  .visible(false)
  .argument('<status>', 'Status of autopilot', ['off', 'on'])
  .help('Autopilot status is either on or off')
  .help('Mirroring and urls require lnd --autopilot.heuristic=externalscore:1')
  .option('--dryrun', 'Show scoring without changing autopilot settings')
  .option('--mirror <pubkey>', 'Mirror channels of node', REPEATABLE)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Set autopilot on saved node')
  .option('--url <url>', 'Follow nodes from a scoring URL', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return setAutopilot({
          request,
          is_dry_run: !!options.dryrun,
          is_enabled: args.status === 'on',
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          mirrors: flatten([options.mirror].filter(n => !!n)),
          node: options.node,
          urls: flatten([options.url].filter(n => !!n)),
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get local balance information
  .command('balance', 'Get total tokens')
  .help('Sums balances on-chain, in channels, and pending, minus commit fees')
  .option('--above <tokens>', 'Return tokens above watermark', INT)
  .option('--below <tokens>', 'Return tokens below watermark', INT)
  .option('--confirmed', 'Return confirmed funds only')
  .option('--node <node_name>', 'Node to get balance for')
  .option('--offchain', 'List only off-chain tokens')
  .option('--onchain', 'List only on-chain tokens')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getBalance({
          above: options.above,
          below: options.below,
          is_confirmed: !!options.confirmed,
          is_offchain_only: !!options.offchain,
          is_onchain_only: !!options.onchain,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          node: options.node,
        },
        returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the number of days until the RPC cert expires
  .command('cert-validity-days', 'Number of days until the cert is invalid')
  .option('--below <number_of_days>', 'Return number of days below mark', INT)
  .option('--node <node_name>', 'Node to check cert on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      return getCertValidityDays({
        logger,
        below: options.below,
        node: options.node,
      },
      returnNumber({logger, reject, resolve, number: 'days'}));
    });
  })

  // Deposit coins
  .command('chain-deposit', 'Deposit coins in the on-chain wallet')
  .argument('[amount]', 'Amount to receive', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to deposit coins to')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getDepositAddress({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          tokens: args.amount,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Create on-chain submarine swap
  .command('chain-receive', 'Receive funds on-chain via submarine swap')
  .argument('[amount]', 'Amount to receive', INT, 1e6)
  .option('--api-key <api_key>', 'Pre-paid API key to use', hexMatch)
  .option('--in <peer>', 'Request receiving through a specific peer')
  .option('--max-fee <max_fee>', 'Max fee in tokens to pay', INT, 4000)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to receive funds on')
  .option('--recovery <refund_recovery>', 'Attempt refund of swap', hexMatch)
  .option('--refund-address <refund_address>', 'Refund address for swap')
  .option('--service-socket <swap_service_socket>', 'host:port for service')
  .option('--test-refund', 'Reduce refund timeout height to test refund')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return swapIn({
          fetch,
          logger,
          api_key: options.apiKey || undefined,
          in_through: options.in || undefined,
          is_refund_test: options.testRefund,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee: options.maxFee,
          node: options.node,
          recovery: options.recovery,
          refund_address: options.refundAddress,
          socket: options.serviceSocket || undefined,
          tokens: args.amount,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the current chain fee rates
  .command('chainfees', 'Get the current chain fee estimates')
  .help('Lookup chain fee estimates at various confirm targets')
  .option('--blocks <depth>', 'Blocks confirm target depth to estimate to')
  .option('--file <path>', 'Write the output to a JSON file at desired path')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get chain fees view from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getChainFees({
          blocks: options.blocks,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({
          logger,
          reject,
          resolve,
          file: options.file,
          write: writeFile,
        }));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Show a chart of fees earned
  .command('chart-fees-earned', 'Get a chart of earned routing fees')
  .argument('[via_peer]', 'Routing fees earned via a specified peer')
  .help('Show the routing fees earned')
  .option('--count', 'Show count of forwards instead of fees earned')
  .option('--days <days>', 'Chart fees over the past number of days', INT, 60)
  .option('--forwarded', 'Show amount forwarded instead of fees earned')
  .option('--node <node_name>', 'Get saved node fees earned', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getFeesChart({
          days: options.days,
          is_count: options.count,
          is_forwarded: options.forwarded,
          lnds: (await getLnds({logger, nodes: options.node})).lnds,
          via: args.viaPeer,
        },
        returnChart({logger, reject, resolve, data: 'data'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Show a chart of routing fees paid
  .command('chart-fees-paid', 'Get a chart of paid routing fees')
  .help('Show the routing fees paid to forwarding nodes')
  .option('--days <days>', 'Chart fees over the past number of days', INT, 60)
  .option('--most-fees', 'View table of fees paid per node')
  .option('--most-forwarded', 'View table of forwarded per node')
  .option('--network', 'Show only non-peers in table view')
  .option('--node <node_name>', 'Get fees chart for saved node(s)', REPEATABLE)
  .option('--peers', 'Show only peers in table view')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const chart = returnChart({logger, reject, resolve, data: 'data'});
      const table = returnObject({logger, reject, resolve, table: 'rows'});

      try {
        return getFeesPaid({
          days: options.days,
          is_most_fees_table: options.mostFees,
          is_most_forwarded_table: options.mostForwarded,
          is_network: options.network,
          is_peer: options.peers,
          lnds: (await getLnds({logger, nodes: options.node})).lnds,
        },
        (options.mostFees || options.mostForwarded) ? table : chart);
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Chart earnings from payments received
  .command('chart-payments-received', 'Get a chart of received payments')
  .help('Show chart for settled invoices from external parties')
  .option('--days <days>', 'Chart over the past number of days', INT, 60)
  .option('--node <node_name>', 'Get payments from saved node(s)', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getReceivedChart({
          days: options.days,
          lnds: (await getLnds({logger, nodes: options.node})).lnds,
        },
        returnChart({logger, reject, resolve, data: 'data'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Determine the outcomes of channel closings
  .command('closed', 'Get the status of a channel closings')
  .help('Channel closes with chain-transaction derived resolution details')
  .option('--limit [limit]', 'Limit of closings to get', INT, 20)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Get channel closes from saved node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getChannelCloses({
          request,
          limit: options.limit,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Export LND credentials
  .command('credentials', 'Export local credentials')
  .help('Output encrypted remote access credentials. Use with "nodes --add"')
  .option('--cleartext', 'Output remote access credentials without encryption')
  .option('--days <days>', 'Expiration days for credentials', INT, 365)
  .option('--node <node_name>', 'Get credentials for a saved node')
  .option('--nospend', 'Credentials do not include spending privileges')
  .option('--readonly', 'Credentials only include read permissions')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getCredentials({
        logger,
        ask: (n, cbk) => inquirer.prompt([n]).then(res => cbk(res)),
        expire_days: options.days,
        is_cleartext: options.cleartext,
        is_nospend: options.nospend,
        is_readonly: options.readonly,
        node: options.node,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Decrypt a message
  .command('decrypt', 'Decrypt data using the node key')
  .visible(false)
  .argument('<encrypted>', 'Encrypted message')
  .help('Decrypt a message encrypted to the node key or to another node key')
  .option('--node <node_name>', 'Node to decrypt with')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return decryptWithNode({
          encrypted: args.encrypted,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Delete all payments
  .command('delete-payments-history', 'Delete all records of past payments')
  .visible(false)
  .option('--node <node_name>', 'Node to delete all past payments on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return deletePayments({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Encrypt a message
  .command('encrypt', 'Encrypt data using the node key')
  .visible(false)
  .help('Encrypt a message to the node key or to another node key')
  .option('--node <node_name>', 'Node to encrypt with')
  .option('--message <message>', 'Text message to encrypt')
  .option('--to <to>', 'Encrypt message to another node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return encryptToNode({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          message: options.message,
          to: options.to,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Fan out utxos
  .command('fanout', 'Fan out utxos')
  .argument('<size>', 'UTXO minimum size', INT)
  .argument('<count>', 'Desired number of total utxos', INT)
  .help('Make a bunch of utxos by making a tx with a bunch of outputs')
  .option('--confirmed', 'Only consider confirmed existing utxos')
  .option('--dryrun', 'Execute a fan-out dry run')
  .option('--feerate <feerate>', 'Feerate in per vbyte rate', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to do fan out for')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return splitUtxos({
          count: args.count,
          is_confirmed: !!options.confirmed,
          is_dry_run: !!options.dryrun,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          size: args.size,
          tokens_per_vbyte: options.feerate,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Show and set outbound fee rates
  .command('fees', 'Show and adjust outbound fee rates')
  .help('List out fee rates, fix problems with routing policies, set out fees')
  .help('When setting fee, if channels pending, will wait for confirm to set')
  .help('Set-fee-rate can use formulas: https://formulajs.info/functions/')
  .help('You can use INBOUND_FEE_RATE to mirror an inbound fee')
  .help('Specify PERCENT(0.00) to set the fee as a fraction of routed amount')
  .help('Specify BIPS() to set the fee as parts per thousand')
  .help('You can use INBOUND and OUTBOUND in formulas for IF formulas')
  .option('--node <node_name>', 'Node to find record on')
  .option('--set-fee-rate <rate>', 'Forward fee in parts per million')
  .option('--to <peer>', 'Peer public key or alias to set fees', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return adjustFees({
          logger,
          fee_rate: options.setFeeRate,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          to: flatten([options.to].filter(n => !!n)),
        },
        returnObject({logger, reject, resolve, table: 'rows'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Query the node to search for something
  .command('find', 'Find a record')
  .help('Look for something in the node db that matches a query')
  .argument('<query>', 'Query for a record')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to find record on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return findRecord({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          query: args.query,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get forwards
  .command('forwards', 'Get forwards')
  .help('Peers where routing has taken place from inbound and outbound sides')
  .option('--complete', 'Show complete set of records in non table view')
  .option('--days <days>', 'Number of past days to evaluate', INT)
  .option('--in <from>', 'Forwards that originated from a specific peer')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get forwards for')
  .option('--out <to>', 'Forwards that sent out to a specified peer')
  .action((args, options, logger) => {
    const table = !!options.complete ? undefined : 'rows';

    return new Promise(async (resolve, reject) => {
      const {lnd} = await authenticatedLnd({logger, node: options.node});

      try {
        return getForwards({
          lnd,
          days: options.days,
          from: (await findKey({lnd, query: options.in})).public_key,
          is_monochrome: !!options.noColor,
          is_table: !options.complete,
          to: (await findKey({lnd, query: options.out})).public_key,
        },
        returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Gateway service
  .command('gateway', 'Request gateway for https://ln-operator.github.io/')
  .help('Start LND gateway server listening for Web UI access')
  .help('Using the --remote option generates credentials for a remote gateway')
  .option('--node <node_name>', 'Node for gateway')
  .option('--port <port>', 'Port for gateway', INT, 4805)
  .option('--remote <url>', 'Output credentials for a remote gateway')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return gateway({
          logger,
          credentials: await lndCredentials({node: options.node}),
          port: options.port,
          remote: options.remote,
        });
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Give a peer some tokens
  .command('gift', 'Give a direct peer some free funds off-chain')
  .visible(false)
  .help('Send some funds to a connected peer')
  .argument('<target>', 'Peer to give funds to')
  .argument('<amount>', 'Tokens to give', INT)
  .option('--node <node_name>', 'Source node to use to pay gift')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return sendGift({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          to: args.target,
          tokens: args.amount,
        },
        returnNumber({logger, reject, resolve, number: 'gave_tokens'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get inbound liquidity information: available inbound off-chain tokens
  .command('inbound-liquidity', 'Get inbound liquidity size')
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--below <tokens>', 'Return amount above watermark', INT)
  .option('--max-fee-rate <fee_rate>', 'Maximum fee rate to consider', INT)
  .option('--min-score <min_score>', 'Minimum fee rate to consider', INT)
  .option('--node <node_name>', 'Node to get inbound liquidity')
  .option('--top', 'Top percentile inbound liquidity in an individual channel')
  .option('--with <node_public_key>', 'Liquidity with a specific node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getLiquidity({
          request,
          above: options.above || undefined,
          below: options.below || undefined,
          is_top: options.top || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee_rate: options.maxFeeRate || undefined,
          min_node_score: options.minScore || undefined,
          with: options.with || undefined,
        },
        returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Increase inbound liquidity
  .command('increase-inbound-liquidity', 'Increase node inbound liquidity')
  .help('Spend down a channel to get inbound. Fee is an estimate, may be more')
  .help('If you want to control chain fee increases, use show-raw-recoveries')
  .option('--address <out_address>', 'Out chain address to send funds out to')
  .option('--api-key <api_key>', 'Pre-paid API key to use')
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--amount <amount>', 'Amount to increase liquidity', INT, 5e5)
  .option('--confs <confs>', 'Confs to consider reorg safe', INT, 1)
  .option('--dryrun', 'Only show cost estimate for increase')
  .option('--fast', 'Request swap server avoid batching delay')
  .option('--max-deposit <max_deposit>', 'Maximum deposit amount', INT, 5e4)
  .option('--max-fee <max_fee>', 'Maximum estimated fee tokens', INT, 3e4)
  .option('--max-hours <max_hours>', 'Maximum hours to wait', INT, 65)
  .option('--max-paths <max_paths>', 'Maximum paths to attempt', INT, 2)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Increase inbound liquidity on saved node')
  .option('--recovery <recovery>', 'Recover in-progress swap')
  .option('--service-socket', 'Specify a custom swap service address')
  .option('--spend-address', 'Send an exact amount to a specific address')
  .option('--spend-amount', 'Exact amount to send to a specific address')
  .option('--show-raw-recovery', 'Show raw recovery transactions')
  .option('--with <peer>', 'Public key of peer to increase liquidity from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return swapOut({
          fetch,
          logger,
          api_key: options.apiKey || undefined,
          avoid: flatten([options.avoid].filter(n => !!n)),
          confs: options.confs,
          is_fast: options.fast || false,
          is_raw_recovery_shown: options.showRawRecovery || undefined,
          is_dry_run: options.dryrun || false,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_deposit: options.maxDeposit,
          max_fee: options.maxFee,
          max_paths: options.maxPaths || undefined,
          max_wait_blocks: Math.ceil((options.maxHours) * 60 / 10),
          node: options.node || undefined,
          out_address: options.address || undefined,
          peer: options.with || undefined,
          recovery: options.recovery,
          socket: options.serviceSocket || undefined,
          spend_address: options.spendAddress || undefined,
          spend_tokens: options.spendAmount || undefined,
          timeout: 1000 * 60 * 60 * 10,
          tokens: options.amount,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Increase outbound liquidity
  .command('increase-outbound-liquidity', 'Move on-chain funds off-chain')
  .help('Open a new channel to add more off-chain liquidity')
  .option('--amount <amount>', 'Amount to assign to new channel capacity', INT)
  .option('--dryrun', 'Avoid actually opening a channel')
  .option('--fee-rate <fee_rate>', 'Use specific fee rate (per vbyte)', FLOAT)
  .option('--node <node_name>', 'Increase outbound liquidity on saved node')
  .option('--private', 'Mark new channel as private')
  .option('--with <peer_public_key>', 'Select a specific peer to open with')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return openChannel({
          logger,
          request,
          chain_fee_rate: options.feeRate || undefined,
          is_dry_run: options.dryrun,
          is_private: options.private,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          peer: options.with || undefined,
          tokens: options.amount,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the price for liquidity
  .command('liquidity-cost', 'Get the price of liquidity')
  .visible(false)
  .argument('<type>', 'Liquidity direction', swapTypes)
  .argument('<amount>', 'Amount of liquidity to get quote for', INT)
  .argument('<api-key>', 'Swap API key to use', hexMatch)
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--fast', 'Avoid any server batching wait time')
  .option('--node <node_name>', 'Node to get liquidity cost')
  .option('--service-socket', 'Specify a custom swap service address')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await authenticatedLnd({logger, node: options.node});

        const {macaroon, preimage, service} = await getPaidService({
          fetch,
          lnd,
          logger,
          socket: options.serviceSocket,
          token: args.apiKey,
        });

        return getSwapCost({
          lnd,
          logger,
          macaroon,
          preimage,
          service,
          above: options.above,
          is_fast: options.fast || undefined,
          tokens: args.amount,
          type: args.type,
        },
        returnNumber({logger, reject, resolve, number: 'cost'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the history of prices
  .command('market', 'Get the history of prices on a market')
  .visible(false)
  .help('A chart of historic prices. Note: SuredBits price history has a fee!')
  .help(`Pairs: ${Array.from(new Set(marketPairs.map(n => n.toUpperCase())))}`)
  .help(`Markets: ${Array.from(new Set(exchanges.map(n => n.toLowerCase())))}`)
  .argument('[pair]', 'Market pair', marketPairs, 'BTCUSD')
  .argument('[exchange]', 'Exchange', exchanges, 'kraken')
  .option('--max-fee <max_fee>', 'Maximum amount to pay for data', INT, 5)
  .option('--node <node_name>', 'Node to use to pay for price data')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getPriceChart({
        exchange: args.exchange.toLowerCase(),
        fee: options.maxFee,
        node: options.node,
        pair: args.pair.toLowerCase(),
      },
      returnChart({logger, reject, resolve, data: 'prices'}));
    });
  })

  // Saved nodes
  .command('nodes', 'List and edit saved nodes')
  .help('Locking and unlocking requires existing installation of GPG')
  .argument('[node]', 'Specify a saved node')
  .option('--add', 'Add a new node')
  .option('--lock <id>', 'Encrypt node authentication to GPG key', REPEATABLE)
  .option('--remove', 'Remove saved node')
  .option('--unlock', 'Remove encryption from auth macaroon')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return adjustSavedNodes({
        logger,
        spawn,
        ask: (n, cbk) => inquirer.prompt([n]).then(res => cbk(res)),
        fs: {
          writeFile,
          getDirectoryFiles: readdir,
          getFile: readFile,
          getFileStatus: lstat,
          makeDirectory: mkdir,
          removeDirectory: rmdir,
          removeFile: unlink,
        },
        is_registering: options.add || undefined,
        is_removing: options.remove || undefined,
        is_unlocking: options.unlock || undefined,
        lock_credentials_to: flatten([options.lock].filter(n => !!n)),
        node: args.node || undefined,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Open channels
  .command('open', 'Open channels using an external wallet for funding')
  .help('Create channels from an external wallet. Note: do not self-broadcast')
  .argument('<peer_public_keys...>', 'With nodes with public keys')
  .option('--amount <channel_capacity>', 'Capacities to open', REPEATABLE)
  .option('--give <give_amount>', 'Amount to gift to peer', REPEATABLE)
  .option('--node <node_name>', 'Node to open channels')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return openChannels({
          logger,
          request,
          ask: (n, cbk) => inquirer.prompt([n]).then(res => cbk(res)),
          capacities: flatten([options.amount].filter(n => !!n)),
          gives: flatten([options.give].filter(n => !!n)),
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          public_keys: args.peerPublicKeys,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get outbound liquidity information: available outbound off-chain tokens
  .command('outbound-liquidity', 'Get outbound liquidity size')
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--below <tokens>', 'Return amount above watermark', INT)
  .option('--node <node_name>', 'Node to get outbound liquidity amount')
  .option('--top', 'Top percentile inbound liquidity in an individual channel')
  .option('--with <peer_public_key>', 'Liquidity with a specific node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getLiquidity({
          above: options.above || undefined,
          below: options.below || undefined,
          is_outbound: true,
          is_top: options.top || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          with: options.with || undefined,
        },
        returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Pay a payment request, probing first
  .command('pay', 'Pay a payment request, probing first')
  .argument('<request>', 'Payment Request')
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--in <public_key>', 'Route through specific peer of destination')
  .option('--max-fee <max_fee>', 'Maximum fee to pay', INT, 1337)
  .option('--max-paths <paths>', 'Maximum paths to use', INT, 1)
  .option('--message <message>', 'Attach text message to payment')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use to pay payment request')
  .option('--out <public_key>', 'Make first hop through peer', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await authenticatedLnd({logger, node: options.node});

        return pay({
          lnd,
          logger,
          ignore: ignoreFromAvoid({avoid: options.avoid}).ignore,
          in_through: (await findKey({lnd, query: options.in})).public_key,
          is_real_payment: true,
          max_fee: options.maxFee,
          max_paths: options.maxPaths,
          message: options.message,
          out: flatten([options.out].filter(n => !!n)),
          request: args.request,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get a list of channel-connected peers
  .command('peers', 'Get a list of channel-connected peers')
  .help(`Sort options: ${peerSortOptions.join(', ')}`)
  .option('--active', 'Only active peer channels')
  .option('--complete', 'Show complete set of records in non table view')
  .option('--fee-days <past_days>', 'Include fees earned over n days', INT)
  .option('--idle-days <days>', 'No receives or routes for n days', INT)
  .option('--inbound-below <amount>', 'Inbound liquidity below amount', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get peers for')
  .option('--offline', 'Only offline peer channels')
  .option('--omit <key>', 'Omit peer with public key', REPEATABLE)
  .option('--outbound-below <amount>', 'Outbound liquidity below amount', INT)
  .option('--private', 'Only private channels')
  .option('--public', 'Only peers with public channels')
  .option('--sort <by>', 'Sort results by peer attribute', peerSortOptions)
  .action((args, options, logger) => {
    const table = !!options.complete ? undefined : 'rows';

    return new Promise(async (resolve, reject) => {
      try {
        return getPeers({
          earnings_days: options.feeDays,
          idle_days: options.idleDays || undefined,
          inbound_liquidity_below: options.inboundBelow,
          is_active: !!options.active,
          is_monochrome: !!options.noColor,
          is_offline: !!options.offline,
          is_private: !!options.private,
          is_public: !!options.public,
          is_table: !options.complete,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          omit: flatten([options.omit].filter(n => !!n)),
          outbound_liquidity_below: options.outboundBelow,
          sort_by: options.sort,
        },
        returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the current fiat exchange price
  .command('price', 'Get the price')
  .argument('[symbols...]', 'Desired fiat tickers')
  .option('--file <path>', 'Write the output to a JSON file at desired path')
  .option('--from <provider>', 'Rate provider', priceProviders, 'coindesk')
  .option('--no-color', 'Mute all colors')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getPrices({
        request,
        from: options.from,
        symbols: args.symbols.map(n => n.toUpperCase()),
      },
      returnObject({
        logger,
        reject,
        resolve,
        file: options.file,
        write: writeFile,
      }));
    });
  })

  // Determine if a payment request is sendable
  .command('probe', 'Check if a payment request is sendable')
  .help('Simulate paying a payment request without actually paying it')
  .argument('<to>', 'Payment request or node public key')
  .argument('[amount]', 'Amount to probe, default: request amount')
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--find-max', 'Find the maximum routeable amount on success route')
  .option('--in <public_key>', 'Route through specific peer of destination')
  .option('--max-paths <max>', 'Maximum paths to use for find-max', INT, 1)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use for payment request check')
  .option('--out <public_key>', 'Make first hop through peer', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await authenticatedLnd({logger, node: options.node});

        return probe({
          lnd,
          logger,
          destination: args.to.length === 66 ? args.to : undefined,
          find_max: !!options.findMax ? 16777215 : undefined,
          ignore: ignoreFromAvoid({avoid: options.avoid}).ignore,
          in_through: (await findKey({lnd, query: options.in})).public_key,
          max_paths: options.maxPaths,
          out: flatten([options.out].filter(n => !!n)),
          request: args.to.length !== 66 ? args.to : undefined,
          tokens: args.amount || undefined,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Rebalance between peers
  .command('rebalance', 'Rebalance funds between peers')
  .help('Change the liquidity profile of two peers')
  .help('When specifying amount you can use formulas or *k *m for *1e3, *1e6')
  .help('Specifying target liquidity you can use CAPACITY/2, other formulas')
  .option('--amount <amount>', 'Maximum amount to rebalance')
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--avoid-high-inbound', 'Avoid rebalancing when inbound is high')
  .option('--in <pubkey_or_alias>', 'Route in through a specific peer')
  .option('--in-target-outbound <amt>', 'Balance up to outbound amount')
  .option('--max-fee <max_fee>', 'Maximum fee to pay', INT)
  .option('--max-fee-rate <max_fee_rate>', 'Max fee rate to pay', INT)
  .option('--minutes <minutes>', 'Time-out route search after N minutes', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use for payment request check')
  .option('--out <pubkey_or_alias>', 'Route out through a specific peer')
  .option('--out-channel', 'Lock outbound rebalance to channels', REPEATABLE)
  .option('--out-target-inbound <amount>', 'Balance up to inbound amount')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return rebalance({
          logger,
          avoid: flatten([options.avoid].filter(n => !!n)),
          in_through: options.in || undefined,
          in_outbound: options.inTargetOutbound || undefined,
          is_avoiding_high_inbound: options.avoidHighInbound || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee: options.maxFee,
          max_fee_rate: options.maxFeeRate,
          max_rebalance: options.amount,
          node: options.node || undefined,
          out_channels: flatten([options.outChannel].filter(n => !!n)),
          out_inbound: options.outTargetInbound,
          out_through: options.out || undefined,
          timeout_minutes: options.minutes || undefined,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Attempt reconnecting to disconnected channel partners
  .command('reconnect', 'Reconnect to disconnected channel parterners')
  .visible(false)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to attempt reconnects on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return reconnect({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Remove a peer
  .command('remove-peer', 'Close out with a channel-connected peer')
  .argument('[public_key]', 'Choose a specific peer to close with')
  .option('--active', 'Make sure the peer is online')
  .option('--address <address>', 'Address to close out funds to')
  .option('--dryrun', 'Avoid actually closing channels with peer')
  .option('--fee-rate <rate>', 'Fee rate per vbyte to close out with', FLOAT)
  .option('--force', 'Force close channels if they cannot be coop closed')
  .option('--idle-days <days>', 'No receives or routes for n days', INT)
  .option('--inbound-below <amount>', 'Peer inbound is below amount', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to remote peer on')
  .option('--offline', 'Make sure the peer is offline')
  .option('--omit <key>', 'Avoid closing peer with public key', REPEATABLE)
  .option('--outbound-below <amount>', 'Peer outbound is below amount', INT)
  .option('--private', 'Peer is privately connected')
  .option('--public', 'Peer is publicly connected')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await authenticatedLnd({logger, node: options.node});

        return removePeer({
          lnd,
          logger,
          request,
          address: options.address,
          chain_fee_rate: options.feeRate || undefined,
          idle_days: options.idleDays,
          inbound_liquidity_below: options.inboundBelow,
          is_active: !!options.active,
          is_dry_run: !!options.dryrun,
          is_forced: !!options.force,
          is_offline: !!options.offline,
          is_private: !!options.private,
          is_public: !!options.public,
          omit: flatten([options.omit].filter(n => !!n)),
          outbound_liquidity_below: options.outboundBelow,
          public_key: args.publicKey,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // See a general report about the node
  .command('report', 'Report about the node')
  .option('--node <node_name>', 'Node to get report for')
  .option('--styled', 'Add unicode styling to report')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getReport({
        node: options.node,
        style: !!options.styled ? 'styled' : undefined,
      },
      returnOutput({logger, reject, resolve}));
    });
  })

  // Send funds to a destination
  .command('send', 'Send funds to a node')
  .argument('<to>', 'Send to node with public key')
  .option('--amount <amount>', 'Amount to send to destination', INT, 1)
  .option('--message <message>', 'Message to include with payment')
  .option('--no-color', 'Mute all colors')
  .option('--node <name>', 'Node to send funds from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        const {lnd} = await authenticatedLnd({logger, node: options.node});

        return probeDestination({
          lnd,
          logger,
          destination: (await findKey({lnd, query: args.to})).public_key,
          is_push: true,
          is_real_payment: true,
          message: options.message,
          tokens: options.amount,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get a swap API key or inspect an existing one
  .command('swap-api-key', 'Purchase a swap API key or inspect a swap API key')
  .option('--api-key <api_key>', 'Hex encoded full swap API key')
  .option('--purchase', 'Purchase a new swap API key')
  .option('--macaroon <macaroon>', 'Hex encoded macaroon of swap API key')
  .option('--node <node_name>', 'Node to use to pay for API key')
  .option('--preimage <preimage>', 'Hex encoded preimage of swap API key')
  .option('--service-socket <swap_service_socket>', 'host:port for service')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return swapApiKey({
          fetch,
          logger,
          api_key: options.apiKey,
          is_purchase: options.purchase,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          macaroon: options.macaroon,
          node: options.node,
          preimage: options.preimage,
          socket: options.serviceSocket,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Link up Telegram bot
  .command('telegram', 'Post updates to a Telegram bot')
  .help('Connect to a Telegram bot. Create bot: tg://resolve?domain=botfather')
  .help('Supported updates: forwards, received payments')
  .option('--budget <amount>', 'Spending amount to allow', INT, Number())
  .option('--connect <connect_code>', 'Connection code', INT)
  .option('--node <node_name>', 'Node to connect to Telegram', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return connectToTelegram({
          logger,
          request,
          fs: {
            writeFile,
            getFile: readFile,
            getFileStatus: statSync,
            makeDirectory: mkdir,
          },
          id: options.connect,
          nodes: flatten([options.node].filter(n => !!n)),
          payments: {limit: options.budget}
        });
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Unlock wallet
  .command('unlock', 'Unlock wallet if locked')
  .help('Check if the wallet is locked, if so use a password file to unlock')
  .argument('<path_to_password_file>', 'Path to password file')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to unlock')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return unlockWallet({
        node: options.node,
        path_to_password_file: args.pathToPasswordFile,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Get utxos
  .command('utxos', 'Get a list of utxos')
  .option('--confirmed', 'Return only confirmed utxos')
  .option('--count', 'Return the count of utxos')
  .option('--count-below <below>', 'Return only count below number', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get utxos for')
  .option('--size', 'Utxos of size greater than or equal to specified amount')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getUtxos({
          count_below: options.countBelow,
          is_confirmed: !!options.confirmed,
          is_count: !!options.count,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          min_tokens: options.size || undefined,
          node: options.node,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  });

prog.parse(process.argv);
