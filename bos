#!/usr/bin/env node
const {lstat} = require('fs');
const {mkdir} = require('fs');
const {readdir} = require('fs');
const {readFile} = require('fs');
const {rmdir} = require('fs');
const {spawn} = require('child_process');
const {unlink} = require('fs');
const {writeFile} = require('fs');

const inquirer = require('inquirer');
const prog = require('caporal');
const {rateProviders} = require('ln-accounting');
const request = require('@alexbosworth/request');

const {accountingCategories} = require('./balances');
const {adjustSavedNodes} = require('./nodes');
const {authenticatedLnd} = require('./lnd');
const {encryptToNode} = require('./encryption');
const {exchanges} = require('./fiat');
const {decryptWithNode} = require('./encryption');
const {findRecord} = require('./lnd');
const {gateway} = require('./lnd');
const {getAccountingReport} = require('./balances');
const {getBalance} = require('./balances');
const {getCertValidityDays} = require('./lnd');
const {getChainFees} = require('./chain');
const {getChannelCloses} = require('./chain');
const {getCoindeskRates} = require('./fiat');
const {getCredentials} = require('./lnd');
const {getDepositAddress} = require('./chain');
const {getFeesChart} = require('./routing');
const {getFeesPaid} = require('./routing');
const {getForwards} = require('./network');
const {getLiquidity} = require('./balances');
const {getLnds} = require('./lnd');
const {getPeers} = require('./network');
const {getPriceChart} = require('./fiat');
const {getReport} = require('./wallets');
const {getSwapCost} = require('./swaps');
const {getSwapService} = require('./swaps');
const {getUtxos} = require('./chain');
const {ignoreFromAvoid} = require('./routing');
const {lndCredentials} = require('./lnd');
const marketPairs = require('./fiat').pairs;
const {openChannel} = require('./network');
const {probeDestination} = require('./network');
const {rebalance} = require('./swaps');
const {reconnect} = require('./network');
const {removePeer} = require('./network');
const {returnChart} = require('./responses');
const {returnNumber} = require('./responses');
const {returnObject} = require('./responses');
const {returnOutput} = require('./responses');
const {sendGift} = require('./network');
const {setAutopilot} = require('./network');
const {splitUtxos} = require('./chain');
const {startTelegramBot} = require('./telegram');
const {swapApiKey} = require('./swaps');
const {swapIn} = require('./swaps');
const {swapOut} = require('./swaps');
const {swapTypes} = require('./swaps');
const {unlockWallet} = require('./wallets');
const {version} = require('./package');

const {exit} = process;
const flatten = arr => [].concat(...arr);
const {FLOAT} = prog;
const hexMatch = /^[0-9a-f]+$/i;
const {INT} = prog;
const {isArray} = Array;
const {keys} = Object;
const months = [...Array(12).keys()].map(n => ++n);
const {REPEATABLE} = prog;
const yearMatch = /^\d{4}$/;

prog
  .version(version)

  // Get accounting information
  .command('accounting', 'Get an accounting rundown')
  .argument('<category>', 'Report category', keys(accountingCategories))
  .help(`Categories: ${keys(accountingCategories).join(', ')}`)
  .help(`Rate providers: ${rateProviders.join(', ')}`)
  .option('--csv', 'Output a CSV')
  .option('--month <month>', 'Show only records for specific month', months)
  .option('--node <node_name>', 'Get details from named node')
  .option('--rate-provider <rate_provider>', 'Rate provider', rateProviders)
  .option('--year <year>', 'Show only records for specified year', yearMatch)
  .action((args, options, logger) => {
    const table = !!options.csv ? null : 'rows';

    return new Promise(async (resolve, reject) => {
      try {
        return getAccountingReport({
          request,
          category: args.category,
          is_csv: !!options.csv,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          month: options.month,
          node: options.node,
          rate_provider: options.rateProvider,
          year: options.year,
        },
        returnObject({logger, reject, resolve, table}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Direct autopilot to mirror one or more nodes on the network
  .command('autopilot', 'Enable autopilot')
  .visible(false)
  .argument('<status>', 'Status of autopilot', ['off', 'on'])
  .help('Autopilot status is either on or off')
  .help('Mirroring and urls require lnd --autopilot.heuristic=externalscore:1')
  .option('--dryrun', 'Show scoring without changing autopilot settings')
  .option('--mirror <pubkey>', 'Mirror channels of node', REPEATABLE)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Set autopilot on saved node')
  .option('--url <url>', 'Follow nodes from a scoring URL', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return setAutopilot({
          request,
          is_dry_run: !!options.dryrun,
          is_enabled: args.status === 'on',
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          mirrors: flatten([options.mirror].filter(n => !!n)),
          node: options.node,
          urls: flatten([options.url].filter(n => !!n)),
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get local balance information
  .command('balance', 'Get total tokens')
  .help('Sums balances on-chain, in channels, and pending, minus commit fees')
  .option('--above <tokens>', 'Return tokens above watermark', INT)
  .option('--below <tokens>', 'Return tokens below watermark', INT)
  .option('--confirmed', 'Return confirmed funds only')
  .option('--node <node_name>', 'Node to get balance for')
  .option('--offchain', 'List only off-chain tokens')
  .option('--onchain', 'List only on-chain tokens')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getBalance({
          above: options.above,
          below: options.below,
          is_confirmed: !!options.confirmed,
          is_offchain_only: !!options.offchain,
          is_onchain_only: !!options.onchain,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          node: options.node,
        },
        returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the number of days until the RPC cert expires
  .command('cert-validity-days', 'Number of days until the cert is invalid')
  .option('--below <number_of_days>', 'Return number of days below mark', INT)
  .option('--node <node_name>', 'Node to check cert on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      return getCertValidityDays({
        logger,
        below: options.below,
        node: options.node,
      },
      returnNumber({logger, reject, resolve, number: 'days'}));
    });
  })

  // Deposit coins
  .command('chain-deposit', 'Deposit coins in the on-chain wallet')
  .argument('[amount]', 'Amount to receive', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to deposit coins to')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getDepositAddress({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          tokens: args.amount,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Create on-chain submarine swap
  .command('chain-receive', 'Receive funds on-chain via submarine swap')
  .argument('[amount]', 'Amount to receive', INT, 1e6)
  .option('--api-key <api_key>', 'Pre-paid API key to use', hexMatch)
  .option('--in <peer>', 'Request receiving through a specific peer')
  .option('--max-fee <max_fee>', 'Max fee in tokens to pay', INT, 4000)
  .option('--no-auth', 'Avoid using authenticated service')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to receive funds on')
  .option('--recovery <refund_recovery>', 'Attempt refund of swap')
  .option('--refund-address <refund_address>', 'Refund address for swap')
  .option('--test-refund', 'Reduce refund timeout height to test refund')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return swapIn({
          logger,
          api_key: options.apiKey || undefined,
          in_through: options.in || undefined,
          is_free: options.noAuth || false,
          is_refund_test: options.testRefund,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee: options.maxFee,
          node: options.node,
          recovery: options.recovery,
          refund_address: options.refundAddress,
          tokens: args.amount,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the current chain fee rates
  .command('chainfees', 'Get the current chain fee estimates')
  .help('Lookup chain fee estimates at various confirm targets')
  .option('--blocks <depth>', 'Blocks confirm target depth to estimate to')
  .option('--file <path>', 'Write the output to a JSON file at desired path')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get chain fees view from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getChainFees({
          blocks: options.blocks,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({
          logger,
          reject,
          resolve,
          file: options.file,
          write: writeFile,
        }));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Show a chart of fees earned
  .command('chart-fees-earned', 'Get a chart of earned routing fees')
  .argument('[via_peer]', 'Routing fees earned via a specified peer')
  .help('Show the routing fees earned')
  .option('--count', 'Show count of forwards instead of fees earned')
  .option('--days <days>', 'Chart fees over the past number of days', INT, 60)
  .option('--node <node_name>', 'Get saved node fees earned', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getFeesChart({
          days: options.days,
          is_count: options.count,
          lnds: (await getLnds({logger, nodes: options.node})).lnds,
          via: args.viaPeer,
        },
        returnChart({logger, reject, resolve, data: 'data'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Show a chart of routing fees paid
  .command('chart-fees-paid', 'Get a chart of paid routing fees')
  .help('Show the routing fees paid to forwarding nodes')
  .option('--days <days>', 'Chart fees over the past number of days', INT, 60)
  .option('--most-fees', 'View table of fees paid per node')
  .option('--most-forwarded', 'View table of forwarded per node')
  .option('--network', 'Show only non-peers in table view')
  .option('--node <node_name>', 'Get fees paid chart for saved node')
  .option('--peers', 'Show only peers in table view')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      const chart = returnChart({logger, reject, resolve, data: 'data'});
      const table = returnObject({logger, reject, resolve, table: 'rows'});

      try {
        return getFeesPaid({
          days: options.days,
          is_most_fees_table: options.mostFees,
          is_most_forwarded_table: options.mostForwarded,
          is_network: options.network,
          is_peer: options.peers,
          lnds: (await getLnds({logger, nodes: options.node})).lnds,
        },
        (options.mostFees || options.mostForwarded) ? table : chart);
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Determine the outcomes of channel closings
  .command('closed', 'Get the status of a channel closings')
  .help('Channel closes with chain-transaction derived resolution details')
  .option('--limit [limit]', 'Limit of closings to get', INT, 20)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Get channel closes from saved node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getChannelCloses({
          limit: options.limit,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Export LND credentials from the standard
  .command('credentials', 'Export local credentials')
  .help('Output encrypted remote access credentials. Use with "nodes --add"')
  .option('--cleartext', 'Output remote access credentials without encryption')
  .option('--days <days>', 'Expiration days for credentials', INT, 365)
  .option('--node <node_name>', 'Get credentials for a saved node')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getCredentials({
        logger,
        ask: (n, cbk) => inquirer.prompt([n]).then(res => cbk(res)),
        expire_days: options.days,
        is_cleartext: options.cleartext,
        node: options.node,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Decrypt a message
  .command('decrypt', 'Decrypt data using the node key')
  .visible(false)
  .argument('<encrypted>', 'Encrypted message')
  .help('Decrypt a message encrypted to the node key or to another node key')
  .option('--node <node_name>', 'Node to decrypt with')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return decryptWithNode({
          encrypted: args.encrypted,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Encrypt a message
  .command('encrypt', 'Encrypt data using the node key')
  .visible(false)
  .help('Encrypt a message to the node key or to another node key')
  .option('--node <node_name>', 'Node to encrypt with')
  .option('--message <message>', 'Text message to encrypt')
  .option('--to <to>', 'Encrypt message to another node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return encryptToNode({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          message: options.message,
          to: options.to,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Fan out utxos
  .command('fanout', 'Fan out utxos')
  .argument('<size>', 'UTXO minimum size', INT)
  .argument('<count>', 'Desired number of total utxos', INT)
  .help('Make a bunch of utxos by making a tx with a bunch of outputs')
  .option('--confirmed', 'Only consider confirmed existing utxos')
  .option('--dryrun', 'Execute a fan-out dry run')
  .option('--feerate <feerate>', 'Feerate in per vbyte rate', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to do fan out for')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return splitUtxos({
        count: args.count,
        is_confirmed: !!options.confirmed,
        is_dry_run: !!options.dryrun,
        node: options.node,
        size: args.size,
        tokens_per_vbyte: options.feerate,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Query the node to search for something
  .command('find', 'Find a record')
  .help('Look for something in the node db that matches a query')
  .argument('<query>', 'Query for a record')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to find record on')
  .action((args, options, logger) => {
    try {
      return new Promise(async (resolve, reject) => {
        return findRecord({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          query: args.query,
        },
        returnObject({logger, reject, resolve}));
      });
    } catch (err) {
      return reject(err);
    }
  })

  // Get forwards
  .command('forwards', 'Get forwards')
  .help('Peers where routing has taken place from inbound and outbound sides')
  .option('--days <days>', 'Number of past days to evaluate', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get forwards for')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getForwards({
          days: options.days,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Start a REST gateway
  .command('gateway', 'Start REST request gateway')
  .visible(false)
  .option('--node <node_name>', 'Node for gateway')
  .option('--port <port>', 'Port for gateway', INT, 4805)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return gateway({
          credentials: await lndCredentials({node: options.node}),
          port: options.port,
        });
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Give a peer some tokens
  .command('gift', 'Give a direct peer some free funds off-chain')
  .visible(false)
  .help('Send some funds to a connected peer')
  .argument('<target>', 'Peer to give funds to')
  .argument('<amount>', 'Tokens to give', INT)
  .option('--node <node_name>', 'Source node to use to pay gift')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return sendGift({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          to: args.target,
          tokens: args.amount,
        },
        returnNumber({logger, reject, resolve, number: 'gave_tokens'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get inbound liquidity information: available inbound off-chain tokens
  .command('inbound-liquidity', 'Get inbound liquidity size')
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--below <tokens>', 'Return amount above watermark', INT)
  .option('--max-fee-rate <fee_rate>', 'Maximum fee rate to consider', INT)
  .option('--min-score <min_score>', 'Minimum fee rate to consider', INT)
  .option('--node <node_name>', 'Node to get inbound liquidity')
  .option('--top', 'Top percentile inbound liquidity in an individual channel')
  .option('--with <node_public_key>', 'Liquidity with a specific node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getLiquidity({
          request,
          above: options.above || undefined,
          below: options.below || undefined,
          is_top: options.top || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee_rate: options.maxFeeRate || undefined,
          min_node_score: options.minScore || undefined,
          with: options.with || undefined,
        },
        returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Increase inbound liquidity
  .command('increase-inbound-liquidity', 'Increase node inbound liquidity')
  .help('Spend down a channel to get inbound. Fee is an estimate, may be more')
  .option('--address <out_address>', 'Out chain address to send funds out to')
  .option('--api-key <api_key>', 'Pre-paid API key to use')
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--amount <amount>', 'Amount to increase liquidity', INT, 5e5)
  .option('--confs <confs>', 'Confs to consider reorg safe', INT, 1)
  .option('--dryrun', 'Only show cost estimate for increase')
  .option('--fast', 'Request swap server avoid batching delay')
  .option('--max-fee <max_fee>', 'Maximum estimated fee tokens', INT, 4000)
  .option('--max-hours <max_hours>', 'Maximum hours to wait', INT, 24)
  .option('--no-auth', 'Avoid using authenticated service')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Increase inbound liquidity on saved node')
  .option('--recovery <recovery>', 'Recover in-progress swap')
  .option('--spend-address', 'Send an exact amount to a specific address')
  .option('--spend-amount', 'Exact amount to send to a specific address')
  .option('--show-raw-recovery', 'Show raw recovery transactions')
  .option('--with <peer>', 'Public key of peer to increase liquidity from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return swapOut({
          logger,
          api_key: options.apiKey || undefined,
          avoid: flatten([options.avoid].filter(n => !!n)),
          confs: options.confs,
          is_fast: options.fast || false,
          is_free: options.noAuth || false,
          is_raw_recovery_shown: options.showRawRecovery || undefined,
          is_dry_run: options.dryrun || false,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee: options.maxFee,
          max_wait_blocks: Math.ceil((options.maxHours) * 60 / 10),
          node: options.node || undefined,
          out_address: options.address || undefined,
          peer: options.with || undefined,
          recovery: options.recovery,
          spend_address: options.spendAddress || undefined,
          spend_tokens: options.spendAmount || undefined,
          timeout: 1000 * 60 * 60 * 10,
          tokens: options.amount,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Increase outbound liquidity
  .command('increase-outbound-liquidity')
  .help('Open a new channel to add more off-chain liquidity')
  .option('--amount <amount>', 'Amount to assign to new channel capacity', INT)
  .option('--dryrun', 'Avoid actually opening a channel')
  .option('--fee-rate <fee_rate>', 'Use specific fee rate (per vbyte)', FLOAT)
  .option('--node <node_name>', 'Increase outbound liquidity on saved node')
  .option('--private', 'Mark new channel as private')
  .option('--with <peer_public_key>', 'Select a specific peer to open with')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return openChannel({
          logger,
          request,
          chain_fee_rate: options.feeRate || undefined,
          is_dry_run: options.dryrun,
          is_private: options.private,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          peer: options.with || undefined,
          tokens: options.amount,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the price for liquidity
  .command('liquidity-cost', 'Get the price of liquidity')
  .visible(false)
  .argument('<type>', 'Liquidity direction', swapTypes)
  .argument('<amount>', 'Amount of liquidity to get quote for', INT)
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--fast', 'Avoid any server batching wait time')
  .option('--node <node_name>', 'Node to get liquidity cost')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getSwapCost({
          above: options.above,
          is_fast: options.fast || undefined,
          service: (await getSwapService({logger, node: options.node})).service,
          tokens: args.amount,
          type: args.type,
        },
        returnNumber({logger, reject, resolve, number: 'cost'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the history of prices
  .command('market', 'Get the history of prices on a market')
  .help('A chart of historic prices. Note: SuredBits price history has a fee!')
  .help(`Pairs: ${Array.from(new Set(marketPairs.map(n => n.toUpperCase())))}`)
  .help(`Markets: ${Array.from(new Set(exchanges.map(n => n.toLowerCase())))}`)
  .argument('[pair]', 'Market pair', marketPairs, 'BTCUSD')
  .argument('[exchange]', 'Exchange', exchanges, 'kraken')
  .option('--max-fee <max_fee>', 'Maximum amount to pay for data', INT, 5)
  .option('--node <node_name>', 'Node to use to pay for price data')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getPriceChart({
        exchange: args.exchange.toLowerCase(),
        fee: options.maxFee,
        node: options.node,
        pair: args.pair.toLowerCase(),
      },
      returnChart({logger, reject, resolve, data: 'prices'}));
    });
  })

  // Saved nodes
  .command('nodes', 'List and edit saved nodes')
  .help('Locking and unlocking requires existing installation of GPG')
  .argument('[node]', 'Specify a saved node')
  .option('--add', 'Add a new node')
  .option('--lock <id>', 'Encrypt node authentication to GPG key', REPEATABLE)
  .option('--remove', 'Remove saved node')
  .option('--unlock', 'Remove encryption from auth macaroon')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return adjustSavedNodes({
        logger,
        spawn,
        ask: (n, cbk) => inquirer.prompt([n]).then(res => cbk(res)),
        fs: {
          writeFile,
          getDirectoryFiles: readdir,
          getFile: readFile,
          getFileStatus: lstat,
          makeDirectory: mkdir,
          removeDirectory: rmdir,
          removeFile: unlink,
        },
        is_registering: options.add || undefined,
        is_removing: options.remove || undefined,
        is_unlocking: options.unlock || undefined,
        lock_credentials_to: flatten([options.lock].filter(n => !!n)),
        node: args.node || undefined,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Get outbound liquidity information: available outbound off-chain tokens
  .command('outbound-liquidity', 'Get outbound liquidity size')
  .option('--above <tokens>', 'Return amount above watermark', INT)
  .option('--below <tokens>', 'Return amount above watermark', INT)
  .option('--node <node_name>', 'Node to get outbound liquidity amount')
  .option('--top', 'Top percentile inbound liquidity in an individual channel')
  .option('--with <peer_public_key>', 'Liquidity with a specific node')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getLiquidity({
          above: options.above || undefined,
          below: options.below || undefined,
          is_outbound: true,
          is_top: options.top || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          with: options.with || undefined,
        },
        returnNumber({logger, reject, resolve, number: 'balance'}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Pay a payment request, probing first
  .command('pay', 'Pay a payment request, probing first')
  .argument('<request>', 'Payment Request')
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--in <public_key>', 'Route through specific peer of destination')
  .option('--max-fee <max_fee>', 'Maximum fee to pay', INT, 1337)
  .option('--message <message>', 'Attach text message to payment')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use to pay payment request')
  .option('--out <public_key>', 'Make first hop through specific peer')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return probeDestination({
          logger,
          ignore: ignoreFromAvoid({avoid: options.avoid}).ignore,
          in_through: options.in,
          is_real_payment: true,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee: options.maxFee,
          message: options.message,
          node: options.node,
          out_through: options.out,
          request: args.request,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get a list of channel-connected peers
  .command('peers', 'Get a list of channel-connected peers')
  .option('--active', 'Only active peer channels')
  .option('--fee-days <past_days>', 'Include fees earned over n days', INT)
  .option('--idle-days <days>', 'No receives or routes for n days', INT)
  .option('--inbound-below <amount>', 'Inbound liquidity below amount', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get peers for')
  .option('--offline', 'Only offline peer channels')
  .option('--omit <key>', 'Omit peer with public key', REPEATABLE)
  .option('--outbound-below <amount>', 'Outbound liquidity below amount', INT)
  .option('--private', 'Only private channels')
  .option('--public', 'Only peers with public channels')
  .option('--sort', 'Sort results by peer attribute')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getPeers({
          earnings_days: options.feeDays,
          idle_days: options.idleDays || undefined,
          inbound_liquidity_below: options.inboundBelow,
          is_active: !!options.active,
          is_offline: !!options.offline,
          is_private: !!options.private,
          is_public: !!options.public,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          omit: flatten([options.omit].filter(n => !!n)),
          outbound_liquidity_below: options.outboundBelow,
          sort_by: options.sort,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get the current fiat exchange price
  .command('price', 'Get the price')
  .argument('[symbols...]', 'Desired fiat tickers')
  .option('--file <path>', 'Write the output to a JSON file at desired path')
  .option('--no-color', 'Mute all colors')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getCoindeskRates({
        request,
        symbols: args.symbols.map(n => n.toUpperCase()),
      },
      returnObject({
        logger,
        reject,
        resolve,
        file: options.file,
        write: writeFile,
      }));
    });
  })

  // Determine if a payment request is sendable
  .command('probe', 'Check if a payment request is sendable')
  .help('Simulate paying a payment request without actually paying it')
  .argument('<to>', 'Payment request or node public key')
  .argument('[amount]', 'Amount to probe, default: request amount', INT)
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--find-max', 'Find the maximum routeable amount on success route')
  .option('--in <public_key>', 'Route through specific peer of destination')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use for payment request check')
  .option('--out <public_key>', 'Make first hop through specific peer')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return probeDestination({
          logger,
          destination: args.to.length === 66 ? args.to : undefined,
          find_max: !!options.findMax ? 4294967 : undefined,
          ignore: ignoreFromAvoid({avoid: options.avoid}).ignore,
          in_through: options.in || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          out_through: options.out || undefined,
          request: args.to.length !== 66 ? args.to : undefined,
          tokens: args.amount || undefined,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Rebalance between peers
  .command('rebalance', 'Rebalance funds between peers')
  .help('Change the liquidity profile of two peers')
  .option('--amount <amount>', 'Maximum amount to rebalance', INT)
  .option('--avoid <pubkey>', 'Avoid forwarding through node', REPEATABLE)
  .option('--avoid-high-inbound', 'Avoid rebalancing when inbound is high')
  .option('--in <pubkey_or_alias>', 'Route in through a specific peer')
  .option('--in-target-outbound <amt>', 'Balance up to outbound amount', INT)
  .option('--max-fee <max_fee>', 'Maximum fee to pay', INT)
  .option('--max-fee-rate <max_fee_rate>', 'Max fee rate to pay', INT)
  .option('--minutes <minutes>', 'Time-out route search after N minutes', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to use for payment request check')
  .option('--out <pubkey_or_alias>', 'Route out through a specific peer')
  .option('--out-channel', 'Lock outbound rebalance to channels', REPEATABLE)
  .option('--out-target-inbound <amount>', 'Balance up to inbound amount', INT)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return rebalance({
          logger,
          avoid: flatten([options.avoid].filter(n => !!n)),
          in_through: options.in || undefined,
          in_outbound: options.inTargetOutbound || undefined,
          is_avoiding_high_inbound: options.avoidHighInbound || undefined,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          max_fee: options.maxFee,
          max_fee_rate: options.maxFeeRate,
          max_rebalance: options.amount,
          node: options.node || undefined,
          out_channels: flatten([options.outChannel].filter(n => !!n)),
          out_inbound: options.outTargetInbound,
          out_through: options.out || undefined,
          timeout_minutes: options.minutes || undefined,
        },
        returnObject({exit, logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Attempt reconnecting to disconnected channel partners
  .command('reconnect', 'Reconnect to disconnected channel parterners')
  .visible(false)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to attempt reconnects on')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return reconnect({
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Remove a peer
  .command('remove-peer', 'Close out with a channel-connected peer')
  .argument('[public_key]', 'Choose a specific peer to close with')
  .option('--active', 'Make sure the peer is online')
  .option('--address <address>', 'Address to close out funds to')
  .option('--dryrun', 'Avoid actually closing channels with peer')
  .option('--fee-rate <rate>', 'Fee rate per vbyte to close out with', FLOAT)
  .option('--force', 'Force close channels if they cannot be coop closed')
  .option('--idle-days <days>', 'No receives or routes for n days', INT)
  .option('--inbound-below <amount>', 'Peer inbound is below amount', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to remote peer on')
  .option('--offline', 'Make sure the peer is offline')
  .option('--omit <key>', 'Avoid closing peer with public key', REPEATABLE)
  .option('--outbound-below <amount>', 'Peer outbound is below amount', INT)
  .option('--private', 'Peer is privately connected')
  .option('--public', 'Peer is publicly connected')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return removePeer({
          logger,
          request,
          address: options.address,
          chain_fee_rate: options.feeRate || undefined,
          idle_days: options.idleDays,
          inbound_liquidity_below: options.inboundBelow,
          is_active: !!options.active,
          is_dry_run: !!options.dryrun,
          is_forced: !!options.force,
          is_offline: !!options.offline,
          is_private: !!options.private,
          is_public: !!options.public,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          omit: flatten([options.omit].filter(n => !!n)),
          outbound_liquidity_below: options.outboundBelow,
          public_key: args.publicKey,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // See a general report about the node
  .command('report', 'Report about the node')
  .option('--node <node_name>', 'Node to get report for')
  .option('--styled', 'Add unicode styling to report')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return getReport({
        node: options.node,
        style: !!options.styled ? 'styled' : undefined,
      },
      returnOutput({logger, reject, resolve}));
    });
  })

  // Send funds to a destination
  .command('send', 'Send funds to a node')
  .argument('<to>', 'Send to node with public key')
  .option('--amount <amount>', 'Amount to send to destination', INT, 1)
  .option('--message <message>', 'Message to include with payment')
  .option('--no-color', 'Mute all colors')
  .option('--node <name>', 'Node to send funds from')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return probeDestination({
          logger,
          destination: args.to,
          is_push: true,
          is_real_payment: true,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          message: options.message,
          tokens: args.amount,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Get a swap API key or inspect an existing one
  .command('swap-api-key', 'Purchase a swap API key or inspect a swap API key')
  .option('--api-key <api_key>', 'Hex encoded full swap API key')
  .option('--purchase', 'Purchase a new swap API key')
  .option('--macaroon <macaroon>', 'Hex encoded macaroon of swap API key')
  .option('--node <node_name>', 'Node to use to pay for API key')
  .option('--preimage <preimage>', 'Hex encoded preimage of swap API key')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return swapApiKey({
          logger,
          api_key: options.apiKey,
          is_purchase: options.purchase,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          macaroon: options.macaroon,
          node: options.node,
          preimage: options.preimage,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Link up Telegram bot
  .command('telegram', 'Post updates to a Telegram bot')
  .help('Connect to a Telegram bot. Create bot: tg://resolve?domain=botfather')
  .help('Supported updates: forwards, received payments')
  .option('--budget <amount>', 'Spending amount to allow', INT, 0)
  .option('--connect <connect_code>', 'Connection code', INT)
  .option('--node <node_name>', 'Node to connect to Telegram', REPEATABLE)
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return startTelegramBot({
          logger,
          request,
          fs: {writeFile, getFile: readFile, makeDirectory: mkdir},
          id: options.connect,
          lnds: (await getLnds({logger, nodes: options.node})).lnds,
          payments: {limit: options.budget}
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  })

  // Unlock wallet
  .command('unlock', 'Unlock wallet if locked')
  .help('Check if the wallet is locked, if so use a password file to unlock')
  .argument('<path_to_password_file>', 'Path to password file')
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to unlock')
  .action((args, options, logger) => {
    return new Promise((resolve, reject) => {
      return unlockWallet({
        node: options.node,
        path_to_password_file: args.pathToPasswordFile,
      },
      returnObject({logger, reject, resolve}));
    });
  })

  // Get utxos
  .command('utxos', 'Get a list of utxos')
  .option('--confirmed', 'Return only confirmed utxos')
  .option('--count', 'Return the count of utxos')
  .option('--count-below <below>', 'Return only count below number', INT)
  .option('--no-color', 'Mute all colors')
  .option('--node <node_name>', 'Node to get utxos for')
  .option('--size', 'Utxos of size greater than or equal to specified amount')
  .action((args, options, logger) => {
    return new Promise(async (resolve, reject) => {
      try {
        return getUtxos({
          count_below: options.countBelow,
          is_confirmed: !!options.confirmed,
          is_count: !!options.count,
          lnd: (await authenticatedLnd({logger, node: options.node})).lnd,
          min_tokens: options.size || undefined,
          node: options.node,
        },
        returnObject({logger, reject, resolve}));
      } catch (err) {
        return reject(err);
      }
    });
  });

prog.parse(process.argv);
